// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CALCULATOR_CALCULATOR_SCHEMA_H_
#define FLATBUFFERS_GENERATED_CALCULATOR_CALCULATOR_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace calculator {
namespace schema {

struct VariableValuePair;

struct Calculator;
struct CalculatorBuilder;
struct CalculatorT;

///corresponds to ascii representation
enum Operation : int8_t {
  Operation_None = -1,
  Operation_Multiply = 42,
  Operation_Add = 43,
  Operation_Subtract = 45,
  Operation_Divide = 47,
  Operation_MIN = Operation_None,
  Operation_MAX = Operation_Divide
};

inline const Operation (&EnumValuesOperation())[5] {
  static const Operation values[] = {
    Operation_None,
    Operation_Multiply,
    Operation_Add,
    Operation_Subtract,
    Operation_Divide
  };
  return values;
}

inline const char *EnumNameOperation(Operation e) {
  switch (e) {
    case Operation_None: return "None";
    case Operation_Multiply: return "Multiply";
    case Operation_Add: return "Add";
    case Operation_Subtract: return "Subtract";
    case Operation_Divide: return "Divide";
    default: return "";
  }
}

enum CalculatorType : int8_t {
  CalculatorType_Simple = 0,
  CalculatorType_Compound = 1,
  CalculatorType_Custom = 2,
  CalculatorType_Term = 3,
  CalculatorType_MIN = CalculatorType_Simple,
  CalculatorType_MAX = CalculatorType_Term
};

inline const CalculatorType (&EnumValuesCalculatorType())[4] {
  static const CalculatorType values[] = {
    CalculatorType_Simple,
    CalculatorType_Compound,
    CalculatorType_Custom,
    CalculatorType_Term
  };
  return values;
}

inline const char * const *EnumNamesCalculatorType() {
  static const char * const names[5] = {
    "Simple",
    "Compound",
    "Custom",
    "Term",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalculatorType(CalculatorType e) {
  if (flatbuffers::IsOutRange(e, CalculatorType_Simple, CalculatorType_Term)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCalculatorType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) VariableValuePair FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t variable_;
  int8_t padding0__;  int16_t padding1__;
  int32_t value_;

 public:
  VariableValuePair()
      : variable_(0),
        padding0__(0),
        padding1__(0),
        value_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  VariableValuePair(int8_t _variable, int32_t _value)
      : variable_(flatbuffers::EndianScalar(_variable)),
        padding0__(0),
        padding1__(0),
        value_(flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
    (void)padding1__;
  }
  int8_t variable() const {
    return flatbuffers::EndianScalar(variable_);
  }
  void mutate_variable(int8_t _variable) {
    flatbuffers::WriteScalar(&variable_, _variable);
  }
  int32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
  void mutate_value(int32_t _value) {
    flatbuffers::WriteScalar(&value_, _value);
  }
};
FLATBUFFERS_STRUCT_END(VariableValuePair, 8);

struct CalculatorT : public flatbuffers::NativeTable {
  typedef Calculator TableType;
  calculator::schema::CalculatorType type = calculator::schema::CalculatorType_Term;
  calculator::schema::Operation operation = calculator::schema::Operation_None;
  int32_t result = 0;
  std::string expression{};
  std::string full_equation{};
  int32_t left_term = 0;
  int32_t right_term = 0;
  std::vector<calculator::schema::VariableValuePair> variables{};
};

struct Calculator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CalculatorT NativeTableType;
  typedef CalculatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_OPERATION = 6,
    VT_RESULT = 8,
    VT_EXPRESSION = 10,
    VT_FULL_EQUATION = 12,
    VT_LEFT_TERM = 14,
    VT_RIGHT_TERM = 16,
    VT_VARIABLES = 18
  };
  calculator::schema::CalculatorType type() const {
    return static_cast<calculator::schema::CalculatorType>(GetField<int8_t>(VT_TYPE, 3));
  }
  bool mutate_type(calculator::schema::CalculatorType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 3);
  }
  calculator::schema::Operation operation() const {
    return static_cast<calculator::schema::Operation>(GetField<int8_t>(VT_OPERATION, -1));
  }
  bool mutate_operation(calculator::schema::Operation _operation) {
    return SetField<int8_t>(VT_OPERATION, static_cast<int8_t>(_operation), -1);
  }
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool mutate_result(int32_t _result) {
    return SetField<int32_t>(VT_RESULT, _result, 0);
  }
  const flatbuffers::String *expression() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPRESSION);
  }
  flatbuffers::String *mutable_expression() {
    return GetPointer<flatbuffers::String *>(VT_EXPRESSION);
  }
  const flatbuffers::String *full_equation() const {
    return GetPointer<const flatbuffers::String *>(VT_FULL_EQUATION);
  }
  flatbuffers::String *mutable_full_equation() {
    return GetPointer<flatbuffers::String *>(VT_FULL_EQUATION);
  }
  int32_t left_term() const {
    return GetField<int32_t>(VT_LEFT_TERM, 0);
  }
  bool mutate_left_term(int32_t _left_term) {
    return SetField<int32_t>(VT_LEFT_TERM, _left_term, 0);
  }
  int32_t right_term() const {
    return GetField<int32_t>(VT_RIGHT_TERM, 0);
  }
  bool mutate_right_term(int32_t _right_term) {
    return SetField<int32_t>(VT_RIGHT_TERM, _right_term, 0);
  }
  const flatbuffers::Vector<const calculator::schema::VariableValuePair *> *variables() const {
    return GetPointer<const flatbuffers::Vector<const calculator::schema::VariableValuePair *> *>(VT_VARIABLES);
  }
  flatbuffers::Vector<const calculator::schema::VariableValuePair *> *mutable_variables() {
    return GetPointer<flatbuffers::Vector<const calculator::schema::VariableValuePair *> *>(VT_VARIABLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OPERATION) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_EXPRESSION) &&
           verifier.VerifyString(expression()) &&
           VerifyOffset(verifier, VT_FULL_EQUATION) &&
           verifier.VerifyString(full_equation()) &&
           VerifyField<int32_t>(verifier, VT_LEFT_TERM) &&
           VerifyField<int32_t>(verifier, VT_RIGHT_TERM) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.EndTable();
  }
  CalculatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CalculatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Calculator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CalculatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CalculatorBuilder {
  typedef Calculator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(calculator::schema::CalculatorType type) {
    fbb_.AddElement<int8_t>(Calculator::VT_TYPE, static_cast<int8_t>(type), 3);
  }
  void add_operation(calculator::schema::Operation operation) {
    fbb_.AddElement<int8_t>(Calculator::VT_OPERATION, static_cast<int8_t>(operation), -1);
  }
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(Calculator::VT_RESULT, result, 0);
  }
  void add_expression(flatbuffers::Offset<flatbuffers::String> expression) {
    fbb_.AddOffset(Calculator::VT_EXPRESSION, expression);
  }
  void add_full_equation(flatbuffers::Offset<flatbuffers::String> full_equation) {
    fbb_.AddOffset(Calculator::VT_FULL_EQUATION, full_equation);
  }
  void add_left_term(int32_t left_term) {
    fbb_.AddElement<int32_t>(Calculator::VT_LEFT_TERM, left_term, 0);
  }
  void add_right_term(int32_t right_term) {
    fbb_.AddElement<int32_t>(Calculator::VT_RIGHT_TERM, right_term, 0);
  }
  void add_variables(flatbuffers::Offset<flatbuffers::Vector<const calculator::schema::VariableValuePair *>> variables) {
    fbb_.AddOffset(Calculator::VT_VARIABLES, variables);
  }
  explicit CalculatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Calculator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Calculator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Calculator> CreateCalculator(
    flatbuffers::FlatBufferBuilder &_fbb,
    calculator::schema::CalculatorType type = calculator::schema::CalculatorType_Term,
    calculator::schema::Operation operation = calculator::schema::Operation_None,
    int32_t result = 0,
    flatbuffers::Offset<flatbuffers::String> expression = 0,
    flatbuffers::Offset<flatbuffers::String> full_equation = 0,
    int32_t left_term = 0,
    int32_t right_term = 0,
    flatbuffers::Offset<flatbuffers::Vector<const calculator::schema::VariableValuePair *>> variables = 0) {
  CalculatorBuilder builder_(_fbb);
  builder_.add_variables(variables);
  builder_.add_right_term(right_term);
  builder_.add_left_term(left_term);
  builder_.add_full_equation(full_equation);
  builder_.add_expression(expression);
  builder_.add_result(result);
  builder_.add_operation(operation);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Calculator> CreateCalculatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    calculator::schema::CalculatorType type = calculator::schema::CalculatorType_Term,
    calculator::schema::Operation operation = calculator::schema::Operation_None,
    int32_t result = 0,
    const char *expression = nullptr,
    const char *full_equation = nullptr,
    int32_t left_term = 0,
    int32_t right_term = 0,
    const std::vector<calculator::schema::VariableValuePair> *variables = nullptr) {
  auto expression__ = expression ? _fbb.CreateString(expression) : 0;
  auto full_equation__ = full_equation ? _fbb.CreateString(full_equation) : 0;
  auto variables__ = variables ? _fbb.CreateVectorOfStructs<calculator::schema::VariableValuePair>(*variables) : 0;
  return calculator::schema::CreateCalculator(
      _fbb,
      type,
      operation,
      result,
      expression__,
      full_equation__,
      left_term,
      right_term,
      variables__);
}

flatbuffers::Offset<Calculator> CreateCalculator(flatbuffers::FlatBufferBuilder &_fbb, const CalculatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CalculatorT *Calculator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CalculatorT>(new CalculatorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Calculator::UnPackTo(CalculatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = operation(); _o->operation = _e; }
  { auto _e = result(); _o->result = _e; }
  { auto _e = expression(); if (_e) _o->expression = _e->str(); }
  { auto _e = full_equation(); if (_e) _o->full_equation = _e->str(); }
  { auto _e = left_term(); _o->left_term = _e; }
  { auto _e = right_term(); _o->right_term = _e; }
  { auto _e = variables(); if (_e) { _o->variables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variables[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Calculator> Calculator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CalculatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCalculator(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Calculator> CreateCalculator(flatbuffers::FlatBufferBuilder &_fbb, const CalculatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CalculatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _operation = _o->operation;
  auto _result = _o->result;
  auto _expression = _o->expression.empty() ? 0 : _fbb.CreateString(_o->expression);
  auto _full_equation = _o->full_equation.empty() ? 0 : _fbb.CreateString(_o->full_equation);
  auto _left_term = _o->left_term;
  auto _right_term = _o->right_term;
  auto _variables = _o->variables.size() ? _fbb.CreateVectorOfStructs(_o->variables) : 0;
  return calculator::schema::CreateCalculator(
      _fbb,
      _type,
      _operation,
      _result,
      _expression,
      _full_equation,
      _left_term,
      _right_term,
      _variables);
}

inline const calculator::schema::Calculator *GetCalculator(const void *buf) {
  return flatbuffers::GetRoot<calculator::schema::Calculator>(buf);
}

inline const calculator::schema::Calculator *GetSizePrefixedCalculator(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<calculator::schema::Calculator>(buf);
}

inline Calculator *GetMutableCalculator(void *buf) {
  return flatbuffers::GetMutableRoot<Calculator>(buf);
}

inline bool VerifyCalculatorBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<calculator::schema::Calculator>(nullptr);
}

inline bool VerifySizePrefixedCalculatorBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<calculator::schema::Calculator>(nullptr);
}

inline void FinishCalculatorBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<calculator::schema::Calculator> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCalculatorBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<calculator::schema::Calculator> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<calculator::schema::CalculatorT> UnPackCalculator(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<calculator::schema::CalculatorT>(GetCalculator(buf)->UnPack(res));
}

inline std::unique_ptr<calculator::schema::CalculatorT> UnPackSizePrefixedCalculator(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<calculator::schema::CalculatorT>(GetSizePrefixedCalculator(buf)->UnPack(res));
}

}  // namespace schema
}  // namespace calculator

#endif  // FLATBUFFERS_GENERATED_CALCULATOR_CALCULATOR_SCHEMA_H_
